
interface Animal {
	void Animal();
	attribute float scalar;
	attribute float[] list;
};

// // Recast

// enum rcLogCategory
// {
// 	"RC_LOG_PROGRESS",
// 	"RC_LOG_WARNING",
// 	"RC_LOG_ERROR"
// };

// enum rcTimerLabel
// {
// 	/// The user defined total time of the build.
// 	"RC_TIMER_TOTAL",
// 	/// A user defined build time.
// 	"RC_TIMER_TEMP",
// 	/// The time to rasterize the triangles. (See: #rcRasterizeTriangle)
// 	"RC_TIMER_RASTERIZE_TRIANGLES",
// 	/// The time to build the compact heightfield. (See: #rcBuildCompactHeightfield)
// 	"RC_TIMER_BUILD_COMPACTHEIGHTFIELD",
// 	/// The total time to build the contours. (See: #rcBuildContours)
// 	"RC_TIMER_BUILD_CONTOURS",
// 	/// The time to trace the boundaries of the contours. (See: #rcBuildContours)
// 	"RC_TIMER_BUILD_CONTOURS_TRACE",
// 	/// The time to simplify the contours. (See: #rcBuildContours)
// 	"RC_TIMER_BUILD_CONTOURS_SIMPLIFY",
// 	/// The time to filter ledge spans. (See: #rcFilterLedgeSpans)
// 	"RC_TIMER_FILTER_BORDER",
// 	/// The time to filter low height spans. (See: #rcFilterWalkableLowHeightSpans)
// 	"RC_TIMER_FILTER_WALKABLE",
// 	/// The time to apply the median filter. (See: #rcMedianFilterWalkableArea)
// 	"RC_TIMER_MEDIAN_AREA",
// 	/// The time to filter low obstacles. (See: #rcFilterLowHangingWalkableObstacles)
// 	"RC_TIMER_FILTER_LOW_OBSTACLES",
// 	/// The time to build the polygon mesh. (See: #rcBuildPolyMesh)
// 	"RC_TIMER_BUILD_POLYMESH",
// 	/// The time to merge polygon meshes. (See: #rcMergePolyMeshes)
// 	"RC_TIMER_MERGE_POLYMESH",
// 	/// The time to erode the walkable area. (See: #rcErodeWalkableArea)
// 	"RC_TIMER_ERODE_AREA",
// 	/// The time to mark a box area. (See: #rcMarkBoxArea)
// 	"RC_TIMER_MARK_BOX_AREA",
// 	/// The time to mark a cylinder area. (See: #rcMarkCylinderArea)
// 	"RC_TIMER_MARK_CYLINDER_AREA",
// 	/// The time to mark a convex polygon area. (See: #rcMarkConvexPolyArea)
// 	"RC_TIMER_MARK_CONVEXPOLY_AREA",
// 	/// The total time to build the distance field. (See: #rcBuildDistanceField)
// 	"RC_TIMER_BUILD_DISTANCEFIELD",
// 	/// The time to build the distances of the distance field. (See: #rcBuildDistanceField)
// 	"RC_TIMER_BUILD_DISTANCEFIELD_DIST",
// 	/// The time to blur the distance field. (See: #rcBuildDistanceField)
// 	"RC_TIMER_BUILD_DISTANCEFIELD_BLUR",
// 	/// The total time to build the regions. (See: #rcBuildRegions, #rcBuildRegionsMonotone)
// 	"RC_TIMER_BUILD_REGIONS",
// 	/// The total time to apply the watershed algorithm. (See: #rcBuildRegions)
// 	"RC_TIMER_BUILD_REGIONS_WATERSHED",
// 	/// The time to expand regions while applying the watershed algorithm. (See: #rcBuildRegions)
// 	"RC_TIMER_BUILD_REGIONS_EXPAND",
// 	/// The time to flood regions while applying the watershed algorithm. (See: #rcBuildRegions)
// 	"RC_TIMER_BUILD_REGIONS_FLOOD",
// 	/// The time to filter out small regions. (See: #rcBuildRegions, #rcBuildRegionsMonotone)
// 	"RC_TIMER_BUILD_REGIONS_FILTER",
// 	/// The time to build heightfield layers. (See: #rcBuildHeightfieldLayers)
// 	"RC_TIMER_BUILD_LAYERS", 
// 	/// The time to build the polygon mesh detail. (See: #rcBuildPolyMeshDetail)
// 	"RC_TIMER_BUILD_POLYMESHDETAIL",
// 	/// The time to merge polygon mesh details. (See: #rcMergePolyMeshDetails)
// 	"RC_TIMER_MERGE_POLYMESHDETAIL",
// 	/// The maximum number of timers.  (Used for iterating timers.)
// 	"RC_MAX_TIMERS"
// };

// interface rcContext {
//     void rcContext(boolean state);
//     void enableLog(boolean state);
// 	void resetLog();
// 	void enableTimer(boolean state);
// 	void resetTimers();
// 	void startTimer([Const] rcTimerLabel label);
// };

// interface rcScopedTimer {
// 	void rcScopedTimer(rcContext ctx, [Const] rcTimerLabel label);
// };

// interface rcConfig {
// 	attribute long width;
// 	attribute long height;
// 	attribute long tileSize;
// 	attribute long borderSize;
// 	attribute float cs;
// 	attribute float ch;
// 	attribute float[] bmin;
// 	attribute float[] bmax;
// 	attribute float walkableSlopeAngle;
// 	attribute long walkableHeight;
// 	attribute long walkableClimb;
// 	attribute long walkableRadius;
// 	attribute long maxEdgeLen;
// 	attribute float maxSimplificationError;
// 	attribute long minRegionArea;
// 	attribute long mergeRegionArea;
// 	attribute long maxVertsPerPoly;
// 	attribute float detailSampleDist;
// 	attribute float detailSampleMaxError;
// };

// interface rcSpan {
// 	attribute long smin;
// 	attribute long smax;
// 	attribute long area; 
// 	[Value] attribute rcSpan next;
// };

// interface rcSpanPool {
// 	[Value] attribute rcSpanPool next;					
// 	[Value] attribute rcSpan items;	
// };



// /// A dynamic heightfield representing obstructed space.
// /// @ingroup recast
// struct rcHeightfield
// {
// 	rcHeightfield();
// 	~rcHeightfield();

// 	int width;			///< The width of the heightfield. (Along the x-axis in cell units.)
// 	int height;			///< The height of the heightfield. (Along the z-axis in cell units.)
// 	float bmin[3];  	///< The minimum bounds in world space. [(x, y, z)]
// 	float bmax[3];		///< The maximum bounds in world space. [(x, y, z)]
// 	float cs;			///< The size of each cell. (On the xz-plane.)
// 	float ch;			///< The height of each cell. (The minimum increment along the y-axis.)
// 	rcSpan** spans;		///< Heightfield of spans (width*height).
// 	rcSpanPool* pools;	///< Linked list of span pools.
// 	rcSpan* freelist;	///< The next free span.

// private:
// 	// Explicitly-disabled copy constructor and copy assignment operator.
// 	rcHeightfield(const rcHeightfield&);
// 	rcHeightfield& operator=(const rcHeightfield&);
// };

// /// Provides information on the content of a cell column in a compact heightfield. 
// struct rcCompactCell
// {
// 	unsigned int index : 24;	///< Index to the first span in the column.
// 	unsigned int count : 8;		///< Number of spans in the column.
// };

// /// Represents a span of unobstructed space within a compact heightfield.
// struct rcCompactSpan
// {
// 	unsigned short y;			///< The lower extent of the span. (Measured from the heightfield's base.)
// 	unsigned short reg;			///< The id of the region the span belongs to. (Or zero if not in a region.)
// 	unsigned int con : 24;		///< Packed neighbor connection data.
// 	unsigned int h : 8;			///< The height of the span.  (Measured from #y.)
// };

// /// A compact, static heightfield representing unobstructed space.
// /// @ingroup recast
// struct rcCompactHeightfield
// {
// 	rcCompactHeightfield();
// 	~rcCompactHeightfield();
// 	int width;					///< The width of the heightfield. (Along the x-axis in cell units.)
// 	int height;					///< The height of the heightfield. (Along the z-axis in cell units.)
// 	int spanCount;				///< The number of spans in the heightfield.
// 	int walkableHeight;			///< The walkable height used during the build of the field.  (See: rcConfig::walkableHeight)
// 	int walkableClimb;			///< The walkable climb used during the build of the field. (See: rcConfig::walkableClimb)
// 	int borderSize;				///< The AABB border size used during the build of the field. (See: rcConfig::borderSize)
// 	unsigned short maxDistance;	///< The maximum distance value of any span within the field. 
// 	unsigned short maxRegions;	///< The maximum region id of any span within the field. 
// 	float bmin[3];				///< The minimum bounds in world space. [(x, y, z)]
// 	float bmax[3];				///< The maximum bounds in world space. [(x, y, z)]
// 	float cs;					///< The size of each cell. (On the xz-plane.)
// 	float ch;					///< The height of each cell. (The minimum increment along the y-axis.)
// 	rcCompactCell* cells;		///< Array of cells. [Size: #width*#height]
// 	rcCompactSpan* spans;		///< Array of spans. [Size: #spanCount]
// 	unsigned short* dist;		///< Array containing border distance data. [Size: #spanCount]
// 	unsigned char* areas;		///< Array containing area id data. [Size: #spanCount]
// };

// /// Represents a heightfield layer within a layer set.
// /// @see rcHeightfieldLayerSet
// struct rcHeightfieldLayer
// {
// 	float bmin[3];				///< The minimum bounds in world space. [(x, y, z)]
// 	float bmax[3];				///< The maximum bounds in world space. [(x, y, z)]
// 	float cs;					///< The size of each cell. (On the xz-plane.)
// 	float ch;					///< The height of each cell. (The minimum increment along the y-axis.)
// 	int width;					///< The width of the heightfield. (Along the x-axis in cell units.)
// 	int height;					///< The height of the heightfield. (Along the z-axis in cell units.)
// 	int minx;					///< The minimum x-bounds of usable data.
// 	int maxx;					///< The maximum x-bounds of usable data.
// 	int miny;					///< The minimum y-bounds of usable data. (Along the z-axis.)
// 	int maxy;					///< The maximum y-bounds of usable data. (Along the z-axis.)
// 	int hmin;					///< The minimum height bounds of usable data. (Along the y-axis.)
// 	int hmax;					///< The maximum height bounds of usable data. (Along the y-axis.)
// 	unsigned char* heights;		///< The heightfield. [Size: width * height]
// 	unsigned char* areas;		///< Area ids. [Size: Same as #heights]
// 	unsigned char* cons;		///< Packed neighbor connection information. [Size: Same as #heights]
// };

// /// Represents a set of heightfield layers.
// /// @ingroup recast
// /// @see rcAllocHeightfieldLayerSet, rcFreeHeightfieldLayerSet 
// struct rcHeightfieldLayerSet
// {
// 	rcHeightfieldLayerSet();
// 	~rcHeightfieldLayerSet();
// 	rcHeightfieldLayer* layers;			///< The layers in the set. [Size: #nlayers]
// 	int nlayers;						///< The number of layers in the set.
// };

// /// Represents a simple, non-overlapping contour in field space.
// struct rcContour
// {
// 	int* verts;			///< Simplified contour vertex and connection data. [Size: 4 * #nverts]
// 	int nverts;			///< The number of vertices in the simplified contour. 
// 	int* rverts;		///< Raw contour vertex and connection data. [Size: 4 * #nrverts]
// 	int nrverts;		///< The number of vertices in the raw contour. 
// 	unsigned short reg;	///< The region id of the contour.
// 	unsigned char area;	///< The area id of the contour.
// };

// /// Represents a group of related contours.
// /// @ingroup recast
// struct rcContourSet
// {
// 	rcContourSet();
// 	~rcContourSet();
// 	rcContour* conts;	///< An array of the contours in the set. [Size: #nconts]
// 	int nconts;			///< The number of contours in the set.
// 	float bmin[3];  	///< The minimum bounds in world space. [(x, y, z)]
// 	float bmax[3];		///< The maximum bounds in world space. [(x, y, z)]
// 	float cs;			///< The size of each cell. (On the xz-plane.)
// 	float ch;			///< The height of each cell. (The minimum increment along the y-axis.)
// 	int width;			///< The width of the set. (Along the x-axis in cell units.) 
// 	int height;			///< The height of the set. (Along the z-axis in cell units.) 
// 	int borderSize;		///< The AABB border size used to generate the source data from which the contours were derived.
// 	float maxError;		///< The max edge error that this contour set was simplified with.
// };

// /// Represents a polygon mesh suitable for use in building a navigation mesh. 
// /// @ingroup recast
// struct rcPolyMesh
// {
// 	rcPolyMesh();
// 	~rcPolyMesh();
// 	unsigned short* verts;	///< The mesh vertices. [Form: (x, y, z) * #nverts]
// 	unsigned short* polys;	///< Polygon and neighbor data. [Length: #maxpolys * 2 * #nvp]
// 	unsigned short* regs;	///< The region id assigned to each polygon. [Length: #maxpolys]
// 	unsigned short* flags;	///< The user defined flags for each polygon. [Length: #maxpolys]
// 	unsigned char* areas;	///< The area id assigned to each polygon. [Length: #maxpolys]
// 	int nverts;				///< The number of vertices.
// 	int npolys;				///< The number of polygons.
// 	int maxpolys;			///< The number of allocated polygons.
// 	int nvp;				///< The maximum number of vertices per polygon.
// 	float bmin[3];			///< The minimum bounds in world space. [(x, y, z)]
// 	float bmax[3];			///< The maximum bounds in world space. [(x, y, z)]
// 	float cs;				///< The size of each cell. (On the xz-plane.)
// 	float ch;				///< The height of each cell. (The minimum increment along the y-axis.)
// 	int borderSize;			///< The AABB border size used to generate the source data from which the mesh was derived.
// 	float maxEdgeError;		///< The max error of the polygon edges in the mesh.
// };

// /// Contains triangle meshes that represent detailed height data associated 
// /// with the polygons in its associated polygon mesh object.
// /// @ingroup recast
// struct rcPolyMeshDetail
// {
// 	unsigned int* meshes;	///< The sub-mesh data. [Size: 4*#nmeshes] 
// 	float* verts;			///< The mesh vertices. [Size: 3*#nverts] 
// 	unsigned char* tris;	///< The mesh triangles. [Size: 4*#ntris] 
// 	int nmeshes;			///< The number of sub-meshes defined by #meshes.
// 	int nverts;				///< The number of vertices in #verts.
// 	int ntris;				///< The number of triangles in #tris.
// };