//--------------------------------------------------------------------------------------------
// Recast.h
//--------------------------------------------------------------------------------------------

enum rcLogCategory
{
	"RC_LOG_PROGRESS",
	"RC_LOG_WARNING",
	"RC_LOG_ERROR"
};

enum rcTimerLabel
{
	/// The user defined total time of the build.
	"RC_TIMER_TOTAL",
	/// A user defined build time.
	"RC_TIMER_TEMP",
	/// The time to rasterize the triangles. (See: #rcRasterizeTriangle)
	"RC_TIMER_RASTERIZE_TRIANGLES",
	/// The time to build the compact heightfield. (See: #rcBuildCompactHeightfield)
	"RC_TIMER_BUILD_COMPACTHEIGHTFIELD",
	/// The total time to build the contours. (See: #rcBuildContours)
	"RC_TIMER_BUILD_CONTOURS",
	/// The time to trace the boundaries of the contours. (See: #rcBuildContours)
	"RC_TIMER_BUILD_CONTOURS_TRACE",
	/// The time to simplify the contours. (See: #rcBuildContours)
	"RC_TIMER_BUILD_CONTOURS_SIMPLIFY",
	/// The time to filter ledge spans. (See: #rcFilterLedgeSpans)
	"RC_TIMER_FILTER_BORDER",
	/// The time to filter low height spans. (See: #rcFilterWalkableLowHeightSpans)
	"RC_TIMER_FILTER_WALKABLE",
	/// The time to apply the median filter. (See: #rcMedianFilterWalkableArea)
	"RC_TIMER_MEDIAN_AREA",
	/// The time to filter low obstacles. (See: #rcFilterLowHangingWalkableObstacles)
	"RC_TIMER_FILTER_LOW_OBSTACLES",
	/// The time to build the polygon mesh. (See: #rcBuildPolyMesh)
	"RC_TIMER_BUILD_POLYMESH",
	/// The time to merge polygon meshes. (See: #rcMergePolyMeshes)
	"RC_TIMER_MERGE_POLYMESH",
	/// The time to erode the walkable area. (See: #rcErodeWalkableArea)
	"RC_TIMER_ERODE_AREA",
	/// The time to mark a box area. (See: #rcMarkBoxArea)
	"RC_TIMER_MARK_BOX_AREA",
	/// The time to mark a cylinder area. (See: #rcMarkCylinderArea)
	"RC_TIMER_MARK_CYLINDER_AREA",
	/// The time to mark a convex polygon area. (See: #rcMarkConvexPolyArea)
	"RC_TIMER_MARK_CONVEXPOLY_AREA",
	/// The total time to build the distance field. (See: #rcBuildDistanceField)
	"RC_TIMER_BUILD_DISTANCEFIELD",
	/// The time to build the distances of the distance field. (See: #rcBuildDistanceField)
	"RC_TIMER_BUILD_DISTANCEFIELD_DIST",
	/// The time to blur the distance field. (See: #rcBuildDistanceField)
	"RC_TIMER_BUILD_DISTANCEFIELD_BLUR",
	/// The total time to build the regions. (See: #rcBuildRegions, #rcBuildRegionsMonotone)
	"RC_TIMER_BUILD_REGIONS",
	/// The total time to apply the watershed algorithm. (See: #rcBuildRegions)
	"RC_TIMER_BUILD_REGIONS_WATERSHED",
	/// The time to expand regions while applying the watershed algorithm. (See: #rcBuildRegions)
	"RC_TIMER_BUILD_REGIONS_EXPAND",
	/// The time to flood regions while applying the watershed algorithm. (See: #rcBuildRegions)
	"RC_TIMER_BUILD_REGIONS_FLOOD",
	/// The time to filter out small regions. (See: #rcBuildRegions, #rcBuildRegionsMonotone)
	"RC_TIMER_BUILD_REGIONS_FILTER",
	/// The time to build heightfield layers. (See: #rcBuildHeightfieldLayers)
	"RC_TIMER_BUILD_LAYERS", 
	/// The time to build the polygon mesh detail. (See: #rcBuildPolyMeshDetail)
	"RC_TIMER_BUILD_POLYMESHDETAIL",
	/// The time to merge polygon mesh details. (See: #rcMergePolyMeshDetails)
	"RC_TIMER_MERGE_POLYMESHDETAIL",
	/// The maximum number of timers.  (Used for iterating timers.)
	"RC_MAX_TIMERS"
};

interface rcContext 
{
    void rcContext(boolean state);
    void enableLog(boolean state);
	void resetLog();
	void enableTimer(boolean state);
	void resetTimers();
	void startTimer([Const] rcTimerLabel label);
};

interface rcScopedTimer 
{
	void rcScopedTimer(rcContext ctx, [Const] rcTimerLabel label);
};

interface rcConfig {
	void rcConfig();
	attribute long width;
	attribute long height;
	attribute long tileSize;
	attribute long borderSize;
	attribute float cs;
	attribute float ch;
	attribute float3 bmin;
	attribute float3 bmax;
	attribute float walkableSlopeAngle;
	attribute long walkableHeight;
	attribute long walkableClimb;
	attribute long walkableRadius;
	attribute long maxEdgeLen;
	attribute float maxSimplificationError;
	attribute long minRegionArea;
	attribute long mergeRegionArea;
	attribute long maxVertsPerPoly;
	attribute float detailSampleDist;
	attribute float detailSampleMaxError;
};

interface rcSpan 
{
	attribute long smin;
	attribute long smax;
	attribute long area; 

	// Who is managing this memory?
	attribute rcSpan next; 
};

interface rcSpanPool 
{
	attribute rcSpanPool next;					
	// How should this get translated?
	//rcSpan items[RC_SPANS_PER_POOL]; //TODO 
};


interface rcHeightfield
{
	void rcHeightfield();

	attribute int width;		
	attribute int height;		
	attribute float3 bmin;  	
	attribute float3 bmax;		
	attribute float cs;			
	attribute float ch;	

	// How should this get translated?
	//attribute rcSpan * spans; //TODO
	attribute rcSpanPool pools;
	attribute rcSpan freelist;
};

interface rcCompactCell
{
	attribute int index;
	attribute int count;
};

interface rcCompactSpan
{
	attribute short y;	
	attribute short reg;
	attribute int con;	
	attribute int h;	
};

interface rcCompactHeightfield
{
	void rcCompactHeightfield();
	attribute int width;			
	attribute int height;			
	attribute int spanCount;		
	attribute int walkableHeight;	
	attribute int walkableClimb;	
	attribute int borderSize;		
	attribute int maxDistance;
	attribute int maxRegions;	
	attribute float3 bmin;		
	attribute float3 bmax;		
	attribute float cs;				
	attribute float ch;				
	attribute rcCompactCell cells;	
	attribute rcCompactSpan spans;	
	attribute short * dist;		
	attribute char * areas;		
};

interface rcHeightfieldLayer
{
	attribute float3 bmin;
	attribute float3 bmax;
	attribute float cs;		
	attribute float ch;		
	attribute int width;	
	attribute int height;	
	attribute int minx;		
	attribute int maxx;		
	attribute int miny;		
	attribute int maxy;		
	attribute int hmin;		
	attribute int hmax;		

	// Is this internal?
	attribute char * heights;
	attribute char * areas;
	attribute char * cons;
};

interface rcHeightfieldLayerSet
{
	void rcHeightfieldLayerSet();
	attribute rcHeightfieldLayer layers;
	attribute int nlayers;
};


interface rcContour
{
	attribute int * verts;		
	attribute int nverts;	
    attribute int * rverts;
	attribute int nrverts;	
	attribute int reg;
	attribute char area;
};


interface rcContourSet
{
	void rcContourSet();
	attribute rcContour conts;
	attribute int nconts;
	attribute float3 bmin;  	
	attribute float3 bmax;		
	attribute float cs;			
	attribute float ch;			
	attribute int width;		
	attribute int height;		
	attribute int borderSize;
	attribute float maxError;	
};

interface rcPolyMesh
{
	void rcPolyMesh();
	attribute short* verts;	
	attribute short* polys;	
	attribute short* regs;	
	attribute short* flags;	
	attribute char* areas;	
	attribute int nverts;		
	attribute int npolys;		
	attribute int maxpolys;		
	attribute int nvp;			
	attribute float3 bmin;	
	attribute float3 bmax;	
	attribute float cs;			
	attribute float ch;			
	attribute int borderSize;
	attribute float maxEdgeError;
};

interface rcPolyMeshDetail
{
	//attribute int * meshes;
	attribute float* verts;		
	attribute char* tris;
	attribute long nmeshes;			
	attribute long nverts;			
	attribute long ntris;			
};

interface FloatArray 
{
	void FloatArray(int size);
	float Get(int index);
	void Set(int index, float value);
};

interface IntArray 
{
	void IntArray(int size);
	int Get(int index);
	void Set(int index, int value);
};

interface CharArray 
{
	void CharArray(int size);
	char Get(int index);
	void Set(int index, char value);
};

interface ShortArray 
{
	void ShortArray(int size);
	int Get(int index);
	void Set(int index, int value);
};


[NoDelete]
interface Recast{
	[Static] void rcFreeHeightField(rcHeightfield hf);
	[Static] rcHeightfield rcAllocHeightfield();
	[Static] rcCompactHeightfield rcAllocCompactHeightfield();
	[Static] void rcFreeCompactHeightfield(rcCompactHeightfield chf);
	[Static] rcHeightfieldLayerSet rcAllocHeightfieldLayerSet();
	[Static] void rcFreeHeightfieldLayerSet(rcHeightfieldLayerSet lset);
	[Static] rcContourSet rcAllocContourSet();
	[Static] void rcFreeContourSet(rcContourSet cset);
	[Static] rcPolyMesh rcAllocPolyMesh();
	[Static] void rcFreePolyMesh(rcPolyMesh pmesh);
	[Static] rcPolyMeshDetail rcAllocPolyMeshDetail();
	[Static] void rcFreePolyMeshDetail(rcPolyMeshDetail dmesh);

	// UPDATED TO NEW METHOD
	[Static] void rcCalcBounds(float[] verts, int nv, float3 bmin, float3 bmax);

	[Static] void rcCalcGridSize([Const] float3 bmin, [Const] float3 bmax, float cs,
							int[] w, int[] h);

	[Static] bool rcCreateHeightfield(rcContext ctx, [Ref] rcHeightfield hf, int width, int height, 
							[Const] float3 bmin, [Const] float3 bmax, float cs, float ch);

	[Static] void rcMarkWalkableTriangles(rcContext ctx, [Const] float walkableSlopeAngle, 
							[Const] float[] verts, int nv,[Const] int[] tris, int nt, char[] areas); 

	[Static] void rcClearUnwalkableTriangles(rcContext ctx, [Const] float walkableSlopeAngle, 
							[Const] float[] verts, int nv,[Const] int[] tris, int nt, char[] areas); 

	[Static] bool rcAddSpan(rcContext ctx, [Ref] rcHeightfield hf, [Const] int x, [Const] int y, 
							[Const] int smin, [Const] int smax, [Const] int area, [Const] int flagMergeThr);

	[Static] bool rcRasterizeTriangle(rcContext ctx, [Const] float3 v0, [Const] float3 v1, 
							[Const] float3 v2, [Const] int area, [Ref] rcHeightfield solid, [Const] int flagMergeThr);

	[Static] bool rcRasterizeTriangles(rcContext ctx, [Const]  float[] verts, [Const]  int nv,
							[Const]  int[] tris, [Const]  char[] areas, [Const]  int nt,
							[Ref] rcHeightfield solid, [Const]  int flagMergeThr);

	[Static] bool rcRasterizeTriangles(rcContext ctx, [Const]  float[] verts, [Const] char[] areas, [Const]  int nt,
							[Ref] rcHeightfield solid, [Const]  int flagMergeThr);

	[Static] void rcFilterLowHangingWalkableObstacles(rcContext ctx, [Const]  int walkableClimb, [Ref] rcHeightfield solid);

	[Static] void rcFilterLedgeSpans(rcContext ctx, [Const]  int walkableHeight,
							[Const]  int walkableClimb, [Ref] rcHeightfield solid);

	[Static] void rcFilterWalkableLowHeightSpans(rcContext ctx, int walkableHeight, [Ref] rcHeightfield solid);

	[Static] int rcGetHeightFieldSpanCount(rcContext ctx, [Ref] rcHeightfield hf);

	[Static] bool rcBuildCompactHeightfield(rcContext ctx, [Const]  int walkableHeight, [Const]  int walkableClimb,
							[Ref] rcHeightfield hf, [Ref] rcCompactHeightfield chf);

	[Static] bool rcErodeWalkableArea(rcContext ctx, int radius, [Ref] rcCompactHeightfield chf);

	[Static] bool rcMedianFilterWalkableArea(rcContext ctx, [Ref] rcCompactHeightfield chf);

	[Static] void rcMarkBoxArea(rcContext ctx, [Const]  float3 bmin, [Const] float3 bmax, char areaId,
							[Ref] rcCompactHeightfield chf);

	[Static] void rcMarkConvexPolyArea(rcContext ctx, [Const] float3 verts, [Const]  int nverts,
							[Const]  float hmin, [Const]  float hmax, char areaId,
							[Ref] rcCompactHeightfield chf);

	[Static] int rcOffsetPoly([Const] float3 verts, [Const]  int nverts, [Const]  float offset,
							float3 outVerts, [Const]  int maxOutVerts);

	[Static] void rcMarkCylinderArea(rcContext ctx, [Const]  float3 pos,
							[Const]  float r, [Const]  float h, char areaId,
							[Ref] rcCompactHeightfield chf);

	[Static] bool rcBuildDistanceField(rcContext ctx, [Ref] rcCompactHeightfield chf);

	[Static] bool rcBuildRegions(rcContext ctx, [Ref] rcCompactHeightfield chf,
							[Const]  int borderSize, [Const]  int minRegionArea, [Const]  int mergeRegionArea);

	[Static] bool rcBuildLayerRegions(rcContext ctx, [Ref] rcCompactHeightfield chf, 
							[Const]  int borderSize, [Const]  int minRegionArea);

	[Static] bool rcBuildRegionsMonotone(rcContext ctx, [Ref] rcCompactHeightfield chf, 
							[Const]  int borderSize, [Const]  int minRegionArea, [Const]  int mergeRegionArea);
};


//--------------------------------------------------------------------------------------------
// DetourMath.h
//--------------------------------------------------------------------------------------------
[NoDelete]
interface DetourMath {
	[Static] float dtMathFabsf(float x);
	[Static] float dtMathSqrtf(float x);
	[Static] float dtMathFloorf(float x);
	[Static] float dtMathCeilf(float x);
	[Static] float dtMathCosf(float x);
	[Static] float dtMathSinf(float x);
	[Static] float dtMathAtan2f(float y, float x);
	[Static] bool dtMathIsfinite(float x);
};

//--------------------------------------------------------------------------------------------
// DetourCommon.h
//--------------------------------------------------------------------------------------------
[NoDelete]
interface DetourCommon {

	[Static] void dtVcross(float3 dest, [Const] float3 v1, [Const] float3 v2);
	[Static] float dtVdot([Const] float3 v1, [Const] float3 v2);
	[Static] void dtVmad(float3 dest, [Const] float3 v1, [Const] float3 v2, [Const] float s);
	[Static] void dtVlerp(float3 dest, [Const] float3 v1, [Const] float3 v2, [Const] float t);
	[Static] void dtVadd(float3 dest, [Const] float3 v1, [Const] float3 v2);
	[Static] void dtVsub(float3 dest, [Const] float3 v1, [Const] float3 v2);
	[Static] void dtVscale(float3 dest, [Const] float3 v, [Const] float t);
	[Static] void dtVmin(float3 mn, [Const] float3 v);
	[Static] void dtVmax(float3 mx, [Const] float3 v);
	[Static] void dtVset(float3 dest, [Const] float x, [Const] float y, [Const] float z);
	[Static] void dtVcopy(float3 dest, [Const] float3 a);
	[Static] float dtVlen([Const] float3 v);
	[Static] float dtVlenSqr([Const] float3 v);
	[Static] float dtVdist([Const] float3 v1, [Const] float3 v2);
	[Static] float dtVdistSqr([Const] float3 v1, [Const] float3 v2);
	[Static] float dtVdist2D([Const] float3 v1, [Const] float3 v2);
	[Static] float dtVdist2DSqr([Const] float3 v1, [Const] float3 v2);
	[Static] void dtVnormalize(float3 v);
	[Static] bool dtVequal([Const] float3 p0, [Const] float3 p1);
	[Static] bool dtVisfinite([Const] float3 v);
	[Static] bool dtVisfinite2D([Const] float3 v);
	[Static] float dtVdot2D([Const] float3 u, [Const] float3 v);
	[Static] float dtVperp2D([Const] float3 u, [Const] float3 v);
	[Static] float dtTriArea2D([Const] float3 a, [Const] float3 b, [Const] float3 c);

    // TODO replace with short3
	[Static] bool dtOverlapQuantBounds([Const] short[] amin, [Const] short[] amax,
						[Const] short[] bmin, [Const] short[] bmax);

	[Static] bool dtOverlapBounds([Const] float3 amin, [Const] float3 amax,
						[Const] float3 bmin, [Const] float3 bmax);

	[Static] void dtClosestPtPointTriangle(float3 closest, [Const] float3 p,
						[Const] float3 a, [Const] float3 b, [Const] float3 c);

	[Static] bool dtClosestHeightPointTriangle([Const] float3 p, [Const] float3 a, [Const] float3 b, 
						[Const] float3 c, [Ref] float h);

	[Static] bool dtIntersectSegmentPoly2D([Const] float3 p0, [Const] float3 p1,
							  [Const] float3 verts, int nverts,
							  [Ref] float tmin, [Ref] float tmax,
							  [Ref] int segMin, [Ref] int segMax);

	[Static] bool dtIntersectSegSeg2D([Const] float3 ap, [Const] float3 aq,
						 [Const] float3 bp, [Const] float3 bq,
						 [Ref] float s, [Ref] float t);

	[Static] bool dtPointInPolygon([Const] float3 pt, [Const] float3 verts, [Const] int nverts);

	[Static] bool dtDistancePtPolyEdgesSqr([Const] float3 pt, [Const] float3 verts, [Const] int nverts,
								float3 ed, float3 et);

	[Static] float dtDistancePtSegSqr2D([Const] float3 pt, [Const] float3 p, [Const] float3 q, [Ref] float t);

	[Static] void dtCalcPolyCenter(float3 tc, [Const] ShortArray idx, int nidx, [Const] float3 verts);

	[Static] bool dtOverlapPolyPoly2D([Const] float3 polya, [Const] int npolya,
							[Const] float3 polyb, [Const] int npolyb);

	[Static] int dtNextPow2(int v);
	[Static] int dtIlog2(int v);
	[Static] int dtAlign4(int x);
	[Static] int dtOppositeTile(int side);
	[Static] void dtSwapByte(char[] a, char[] b);	

	[Static] void dtRandomPointInConvexPoly([Const] float[] pts, [Const] int npts, float[] areas,
								[Const] float s, [Const] float t, float[] out);
};

//--------------------------------------------------------------------------------------------
// DetourStatus.h
//--------------------------------------------------------------------------------------------
typedef dtStatus int;

[NoDelete]
interface DetourStatus 
{
	[Static] bool dtStatusSucceed(dtStatus status);
	[Static] bool dtStatusFailed(dtStatus status);
	[Static] bool dtStatusInProgress(dtStatus status);
	[Static] bool dtStatusDetail(dtStatus status, int detail);
};

//--------------------------------------------------------------------------------------------
// DetourNavMesh.h
//--------------------------------------------------------------------------------------------
typedef dtPolyRef int64;
typedef dtTileRef int64;

interface dtPoly 
{
	attribute int firstLink;
	//attribute short* verts; // TODO original:  unsigned short verts[DT_VERTS_PER_POLYGON];
	//attribute short* neis;  // TODO original:  unsigned short neis[DT_VERTS_PER_POLYGON];
	attribute short flags;
	attribute char vertCount;
	attribute char areaAndtype;
	void setArea(char a);
	void setType(char t);
	[Const] char getArea();
    [Const] char getType();
};

interface dtPolyDetail 
{
	attribute int vertBase;			
	attribute int triBase;			
	attribute char vertCount;		
	attribute char triCount;		
};

interface dtLink 
{
	attribute dtPolyRef ref;		
	attribute int next;				
	attribute char edge;			
	attribute char side;			
	attribute char bmin;			
	attribute char bmax;			
};

interface dtBVNode 
{
	// attribute short* bmin; // TODO replace with short3			
	// attribute short* bmax; // TODO replace with short3	
	attribute int i;					
};

interface dtOffMeshConnection 
{
	// float pos[6]; // TODO original: float pos[6];
	attribute float rad;		
	attribute short poly;
	attribute char flags;
	attribute char side;
	attribute int userId;
};

interface dtMeshHeader 
{
	attribute int magic;				
	attribute int version;			
	attribute int x;					
	attribute int y;					
	attribute int layer;				
	attribute int userId;	
	attribute int polyCount;			
	attribute int vertCount;			
	attribute int maxLinkCount;		
	attribute int detailMeshCount;	
	attribute int detailVertCount;		
	attribute int detailTriCount;		
	attribute int bvNodeCount;		
	attribute int offMeshConCount;	
	attribute int offMeshBase;		
	attribute float walkableHeight;	
	attribute float walkableRadius;	
	attribute float walkableClimb;	
	attribute float3 bmin;			
	attribute float3 bmax;			
	attribute float bvQuantFactor;
};

interface dtMeshTile 
{
	attribute int salt;			
	attribute int linksFreeList;	
	attribute dtMeshHeader header;	
	attribute dtPoly polys; 		  	
	attribute float* verts;
	attribute dtLink links;	
	attribute dtPolyDetail detailMeshes;	
	attribute float* detailVerts;	  
	attribute char* detailTris;
	attribute dtBVNode bvTree;
	attribute dtOffMeshConnection offMeshCons;		
	attribute int dataSize;						
	attribute int flags;							
	attribute dtMeshTile next;			
};

interface dtNavMeshParams 
{
	//float orig[3];		
	attribute float tileWidth;	
	attribute float tileHeight;	
	attribute int maxTiles;		
	attribute int maxPolys;		
};

interface dtNavMesh
{

	void dtNavMesh();

	int init([Const] dtNavMeshParams params);

	int init(CharArray data, [Const] int dataSize, [Const] int flags);

	[Const] dtNavMeshParams getParams();

	//int addTile(CharArray data, int dataSize, int flags, int lastRef, dtTileRef result); //TODO

	//dtStatus removeTile(dtTileRef ref, unsigned char** data, int* dataSize); //TODO

	void calcTileLoc([Const] FloatArray pos, IntArray tx, IntArray ty);

	[Const] dtMeshTile getTileAt([Const] int x, [Const] int y, [Const] int layer);

	//TODO
	//int getTilesAt([Const] int x, [Const] int y, dtMeshTile [Const]** tiles, [Const] int maxTiles);

	int getTileRefAt(int x, int y, int layer);
	
	int getTileRef([Const] dtMeshTile tile);
	
	[Const] dtMeshTile getTileByRef(int ref);
	
	int getMaxTiles();
	
	//TODO
	// [Const] dtMeshTile getTile(int i); 

	// dtStatus getTileAndPolyByRef([Const] dtPolyRef ref, [Const] dtMeshTile** tile, [Const] dtPoly** poly);
	
	// void getTileAndPolyByRefUnsafe([Const] dtPolyRef ref, [Const] dtMeshTile** tile, [Const] dtPoly** poly);

	bool isValidPolyRef(int ref);
	
	int getPolyRefBase([Const] dtMeshTile tile);
	
	int getOffMeshConnectionPolyEndPoints(int prevRef, int polyRef, FloatArray startPos, FloatArray endPos);

	[Const] dtOffMeshConnection getOffMeshConnectionByRef(int ref);
	
	int setPolyFlags(int ref, short flags);

	int getPolyFlags(int ref, ShortArray resultFlags);

	int setPolyArea(int ref, char area);

	int getPolyArea(int ref, CharArray resultArea);

	int getTileStateSize([Const] dtMeshTile tile);

	int storeTileState([Const] dtMeshTile tile, CharArray data, [Const] int maxDataSize);
	
	int restoreTileState(dtMeshTile tile, [Const] CharArray data, [Const] int maxDataSize);
	
	int encodePolyId(int salt, int it, int ip);

	// void decodePolyId(int ref, [Ref] int salt, [Ref] int it, [Ref] int ip); //TODO
	
	int decodePolyIdSalt(int ref);

	int decodePolyIdTile(int ref);

	int decodePolyIdPoly(int ref);
};

[NoDelete]
interface DetourNavMesh 
{
	[Static] int dtGetDetailTriEdgeFlags(char triFlags, int edgeIndex);
	[Static] dtNavMesh dtAllocNavMesh();
	[Static] void dtFreeNavMesh(dtNavMesh navmesh);
};

//--------------------------------------------------------------------------------------------
// DetourNode.h
//--------------------------------------------------------------------------------------------
interface dtNode 
{
	// [Value] attribute FloatArray pos;
	attribute float cost;
	attribute float total;
	attribute int pidx;
	attribute int state;
	attribute int flags;
	attribute int id;
};

// typedef dtNodeIndex short;
// typedef dtPolyRef int64;

interface dtNodePool
{
	void dtNodePool(int maxNodes, int hashSize);
	// dtNode getNode(dtPolyRef id, char state);	
	// [Value] dtNode findNode(dtPolyRef id, char state);
	//int findNodes(dtPolyRef id, dtNode** nodes, const int maxNodes);
	int getNodeIdx([Const] dtNode node);
	dtNode getNodeAtIdx(int idx);	
	int getMemUsed();	
	int getMaxNodes();
	int getHashSize();
 	//dtNodeIndex getFirst(int bucket); //TODO
	//dtNodeIndex getNext(int i); // TODO 
	int getNodeCount();
};


interface dtNodeQueue
{
	void dtNodeQueue(int n);
	void clear();
	dtNode top();
	dtNode pop();
	void push(dtNode node);
	void modify(dtNode node);
	bool empty();
	int getMemUsed();
	int getCapacity();
};
	

//--------------------------------------------------------------------------------------------
// DetourNavMeshBuilder.h
//--------------------------------------------------------------------------------------------
interface dtNavMeshCreateParams 
{
	void dtNavMeshCreateParams();

	// Option 1 - Arrays that get coppied and will use the member variable as size	
	// Currently, setting this will likely leak memory. Unless it's disposed by the dtNavMeshCreateParams class
	//	attribute short [vertCount] verts;

	// Option 2 - Direct pointer access.
	attribute short * verts;
	
	attribute int vertCount;

	//const unsigned short* polys;
	//const unsigned short* polyFlags;
	//const unsigned char* polyAreas;
	attribute int polyCount;							
	attribute int nvp;								
	//const unsigned int* detailMeshes;		
	//const float* detailVerts;				
	attribute int detailVertsCount;					
	//const unsigned char* detailTris;		
	attribute int detailTriCount;
	//const float* offMeshConVerts;
	//const float* offMeshConRad;
	//const unsigned short* offMeshConFlags;
	//const unsigned char* offMeshConAreas;
	//const unsigned char* offMeshConDir;	
	//const unsigned int* offMeshConUserID;
	attribute int offMeshConCount;
	attribute int userId;	
	attribute int tileX;				
	attribute int tileY;				
	attribute int tileLayer;			
	// attribute float bmin;			
	// attribute float bmax;			
	attribute float walkableHeight;
	attribute float walkableRadius;	
	attribute float walkableClimb;	
	attribute float cs;				
	attribute float ch;				
	attribute bool buildBvTree;
};

[NoDelete]
interface DetourNavMeshBuilder
{
	//bool dtCreateNavMeshData(dtNavMeshCreateParams* params, unsigned char** outData, int* outDataSize); // TODO resolve unsigned char**
	[Static] bool dtNavMeshHeaderSwapEndian(CharArray data, [Const] int dataSize);
	[Static] bool dtNavMeshDataSwapEndian(CharArray data, [Const] int dataSize);
};


//--------------------------------------------------------------------------------------------
// DetourNavMeshBuilder.h
//--------------------------------------------------------------------------------------------
interface dtQueryFilter
{
	void dtQueryFilter();	
	// bool passFilter([Const] dtPolyRef ref,[Const] dtMeshTile tile,[Const] dtPoly poly);
	// bool passFilter([Const] dtPolyRef ref,[Const] dtMeshTile tile,[Const] dtPoly poly);

// #ifdef DT_VIRTUAL_QUERYFILTER
// 	virtual float getCost(const float* pa, const float* pb,
// 						  const dtPolyRef prevRef, const dtMeshTile* prevTile, const dtPoly* prevPoly,
// 						  const dtPolyRef curRef, const dtMeshTile* curTile, const dtPoly* curPoly,
// 						  const dtPolyRef nextRef, const dtMeshTile* nextTile, const dtPoly* nextPoly) const;
// #else
// 	float getCost(const float* pa, const float* pb,
// 				  const dtPolyRef prevRef, const dtMeshTile* prevTile, const dtPoly* prevPoly,
// 				  const dtPolyRef curRef, const dtMeshTile* curTile, const dtPoly* curPoly,
// 				  const dtPolyRef nextRef, const dtMeshTile* nextTile, const dtPoly* nextPoly) const;
// #endif

	float getAreaCost([Const] int i);
	void setAreaCost([Const] int i, [Const] float cost);
	short getIncludeFlags();
	void setIncludeFlags([Const] short flags);
	short getExcludeFlags();
	void setExcludeFlags([Const] short flags);
};

interface dtRaycastHit
{
	attribute float t; 
	//attribute float hitNormal[3];
	attribute int hitEdgeIndex;
	//attribute dtPolyRef path;
	attribute int pathCount;
	attribute int maxPath;
	attribute float pathCost;
};

interface dtNavMeshQuery
{
	void dtNavMeshQuery();

	//dtStatus init([Const] dtNavMesh nav, [Const] int maxNodes);
	
	// dtStatus findPath(dtPolyRef startRef, dtPolyRef endRef,
	// 				  [Const] FloatArray startPos, [Const] FloatArray endPos,
	// 				  [Const] dtQueryFilter* filter,
	// 				  dtPolyRef* path, IntArray pathCount, [Const] int maxPath);

	// dtStatus findStraightPath([Const] FloatArray startPos, [Const] FloatArray endPos,
	// 						  [Const] dtPolyRef* path, [Const] int pathSize,
	// 						  FloatArray straightPath, CharArray straightPathFlags, dtPolyRef* straightPathRefs,
	// 						  IntArray straightPathCount, [Const] int maxStraightPath, [Const] int options);

	// dtStatus initSlicedFindPath(dtPolyRef startRef, dtPolyRef endRef,
	// 							[Const] FloatArray startPos, [Const] FloatArray endPos,
	// 							[Const] dtQueryFilter filter, [Const] unsigned int options);

	//dtStatus updateSlicedFindPath([Const] int maxIter, IntArray doneIters);

	// dtStatus finalizeSlicedFindPath(dtPolyRef* path, IntArray pathCount, [Const] int maxPath);
	
	// dtStatus finalizeSlicedFindPathPartial([Const] dtPolyRef* existing, [Const] int existingSize,
	// 									   dtPolyRef* path, IntArray pathCount, [Const] int maxPath);

	// dtStatus findPolysAroundCircle(dtPolyRef startRef, [Const] FloatArray centerPos, [Const] float radius,
	// 							   [Const] dtQueryFilter* filter,
	// 							   dtPolyRef* resultRef, dtPolyRef* resultParent, FloatArray resultCost,
	// 							   IntArray resultCount, [Const] int maxResult);

	// dtStatus findPolysAroundShape(dtPolyRef startRef, [Const] FloatArray verts, [Const] int nverts,
	// 							  [Const] dtQueryFilter* filter,
	// 							  dtPolyRef* resultRef, dtPolyRef* resultParent, FloatArray resultCost,
	// 							  IntArray resultCount, [Const] int maxResult);
	
	// dtStatus getPathFromDijkstraSearch(dtPolyRef endRef, dtPolyRef* path, IntArray pathCount, int maxPath);

	// dtStatus findNearestPoly([Const] FloatArray center, [Const] FloatArray halfExtents,
	// 						 [Const] dtQueryFilter* filter,
	// 						 dtPolyRef* nearestRef, FloatArray nearestPt);

	// dtStatus findNearestPoly([Const] FloatArray center, [Const] FloatArray halfExtents,
	// 						 [Const] dtQueryFilter* filter,
	// 						 dtPolyRef* nearestRef, FloatArray nearestPt, bool* isOverPoly);

	// dtStatus queryPolygons([Const] FloatArray center, [Const] FloatArray halfExtents,
	// 					   [Const] dtQueryFilter* filter,
	// 					   dtPolyRef* polys, IntArray polyCount, [Const] int maxPolys);

	// dtStatus queryPolygons([Const] FloatArray center, [Const] FloatArray halfExtents,
	// 					   [Const] dtQueryFilter* filter, dtPolyQuery* query);

	// dtStatus findLocalNeighbourhood(dtPolyRef startRef, [Const] FloatArray centerPos, [Const] float radius,
	// 								[Const] dtQueryFilter* filter,
	// 								dtPolyRef* resultRef, dtPolyRef* resultParent,
	// 								IntArray resultCount, [Const] int maxResult);

	// dtStatus moveAlongSurface(dtPolyRef startRef, [Const] FloatArray startPos, [Const] FloatArray endPos,
	// 						  [Const] dtQueryFilter* filter,
	// 						  FloatArray resultPos, dtPolyRef* visited, IntArray visitedCount, [Const] int maxVisitedSize);
	
	// dtStatus raycast(dtPolyRef startRef, [Const] FloatArray startPos, [Const] FloatArray endPos,
	// 				 [Const] dtQueryFilter* filter,
	// 				 FloatArray t, FloatArray hitNormal, dtPolyRef* path, IntArray pathCount, [Const] int maxPath);
	
	// dtStatus raycast(dtPolyRef startRef, [Const] FloatArray startPos, [Const] FloatArray endPos,
	// 				 [Const] dtQueryFilter filter, [Const] int options,
	// 				 dtRaycastHit hit, dtPolyRef prevRef = 0);

	// dtStatus findDistanceToWall(dtPolyRef startRef, [Const] FloatArray centerPos, [Const] float maxRadius,
	// 							[Const] dtQueryFilter filter,
	// 							FloatArray hitDist, FloatArray hitPos, FloatArray hitNormal);

	// dtStatus getPolyWallSegments(dtPolyRef ref, [Const] dtQueryFilter* filter,
	// 							 FloatArray segmentVerts, dtPolyRef segmentRefs, IntArray segmentCount,
	// 							 [Const] int maxSegments);

	// dtStatus findRandomPoint([Const] dtQueryFilter filter, float (*frand)(),
	// 						 dtPolyRef randomRef, FloatArray randomPt) [Const];

	// dtStatus findRandomPointAroundCircle(dtPolyRef startRef, [Const] FloatArray centerPos, [Const] float maxRadius,
	// 									 [Const] dtQueryFilter filter, float (*frand)(),
	// 									 dtPolyRef randomRef, FloatArray randomPt); //TODO

	//dtStatus closestPointOnPoly(dtPolyRef ref, [Const] FloatArray pos, FloatArray closest, bool* posOverPoly); //TODO

	// dtStatus closestPointOnPolyBoundary(dtPolyRef ref, [Const] FloatArray pos, FloatArray closest);

	// dtStatus getPolyHeight(dtPolyRef ref, [Const] FloatArray pos, FloatArray height);

	// bool isValidPolyRef(dtPolyRef ref, [Const] dtQueryFilter filter);

	// bool isInClosedList(dtPolyRef ref);

    dtNodePool getNodePool();

	[Const] dtNavMesh getAttachedNavMesh();
};

[NoDelete]
interface DetourNavMeshQuery
{
	[Static] dtNavMeshQuery dtAllocNavMeshQuery();
	[Static] void dtFreeNavMeshQuery(dtNavMeshQuery query);
};
