
// interface Animal {
// 	void Animal();
// 	attribute long size;
// };

// Recast

enum rcLogCategory
{
	"RC_LOG_PROGRESS",
	"RC_LOG_WARNING",
	"RC_LOG_ERROR"
};

enum rcTimerLabel
{
	/// The user defined total time of the build.
	"RC_TIMER_TOTAL",
	/// A user defined build time.
	"RC_TIMER_TEMP",
	/// The time to rasterize the triangles. (See: #rcRasterizeTriangle)
	"RC_TIMER_RASTERIZE_TRIANGLES",
	/// The time to build the compact heightfield. (See: #rcBuildCompactHeightfield)
	"RC_TIMER_BUILD_COMPACTHEIGHTFIELD",
	/// The total time to build the contours. (See: #rcBuildContours)
	"RC_TIMER_BUILD_CONTOURS",
	/// The time to trace the boundaries of the contours. (See: #rcBuildContours)
	"RC_TIMER_BUILD_CONTOURS_TRACE",
	/// The time to simplify the contours. (See: #rcBuildContours)
	"RC_TIMER_BUILD_CONTOURS_SIMPLIFY",
	/// The time to filter ledge spans. (See: #rcFilterLedgeSpans)
	"RC_TIMER_FILTER_BORDER",
	/// The time to filter low height spans. (See: #rcFilterWalkableLowHeightSpans)
	"RC_TIMER_FILTER_WALKABLE",
	/// The time to apply the median filter. (See: #rcMedianFilterWalkableArea)
	"RC_TIMER_MEDIAN_AREA",
	/// The time to filter low obstacles. (See: #rcFilterLowHangingWalkableObstacles)
	"RC_TIMER_FILTER_LOW_OBSTACLES",
	/// The time to build the polygon mesh. (See: #rcBuildPolyMesh)
	"RC_TIMER_BUILD_POLYMESH",
	/// The time to merge polygon meshes. (See: #rcMergePolyMeshes)
	"RC_TIMER_MERGE_POLYMESH",
	/// The time to erode the walkable area. (See: #rcErodeWalkableArea)
	"RC_TIMER_ERODE_AREA",
	/// The time to mark a box area. (See: #rcMarkBoxArea)
	"RC_TIMER_MARK_BOX_AREA",
	/// The time to mark a cylinder area. (See: #rcMarkCylinderArea)
	"RC_TIMER_MARK_CYLINDER_AREA",
	/// The time to mark a convex polygon area. (See: #rcMarkConvexPolyArea)
	"RC_TIMER_MARK_CONVEXPOLY_AREA",
	/// The total time to build the distance field. (See: #rcBuildDistanceField)
	"RC_TIMER_BUILD_DISTANCEFIELD",
	/// The time to build the distances of the distance field. (See: #rcBuildDistanceField)
	"RC_TIMER_BUILD_DISTANCEFIELD_DIST",
	/// The time to blur the distance field. (See: #rcBuildDistanceField)
	"RC_TIMER_BUILD_DISTANCEFIELD_BLUR",
	/// The total time to build the regions. (See: #rcBuildRegions, #rcBuildRegionsMonotone)
	"RC_TIMER_BUILD_REGIONS",
	/// The total time to apply the watershed algorithm. (See: #rcBuildRegions)
	"RC_TIMER_BUILD_REGIONS_WATERSHED",
	/// The time to expand regions while applying the watershed algorithm. (See: #rcBuildRegions)
	"RC_TIMER_BUILD_REGIONS_EXPAND",
	/// The time to flood regions while applying the watershed algorithm. (See: #rcBuildRegions)
	"RC_TIMER_BUILD_REGIONS_FLOOD",
	/// The time to filter out small regions. (See: #rcBuildRegions, #rcBuildRegionsMonotone)
	"RC_TIMER_BUILD_REGIONS_FILTER",
	/// The time to build heightfield layers. (See: #rcBuildHeightfieldLayers)
	"RC_TIMER_BUILD_LAYERS", 
	/// The time to build the polygon mesh detail. (See: #rcBuildPolyMeshDetail)
	"RC_TIMER_BUILD_POLYMESHDETAIL",
	/// The time to merge polygon mesh details. (See: #rcMergePolyMeshDetails)
	"RC_TIMER_MERGE_POLYMESHDETAIL",
	/// The maximum number of timers.  (Used for iterating timers.)
	"RC_MAX_TIMERS"
};

interface rcContext {
    void rcContext(boolean state);
    void enableLog(boolean state);
	void resetLog();
	void enableTimer(boolean state);
	void resetTimers();
	void startTimer([Const] rcTimerLabel label);
};

interface rcScopedTimer {
	void rcScopedTimer(rcContext ctx, [Const] rcTimerLabel label);
};

interface rcConfig {
	attribute long width;
	attribute long height;
	attribute long tileSize;
	attribute long borderSize;
	attribute float cs;
	attribute float ch;
	// attribute float[] bmin;
	// attribute float[] bmax;
	attribute float walkableSlopeAngle;
	attribute long walkableHeight;
	attribute long walkableClimb;
	attribute long walkableRadius;
	attribute long maxEdgeLen;
	attribute float maxSimplificationError;
	attribute long minRegionArea;
	attribute long mergeRegionArea;
	attribute long maxVertsPerPoly;
	attribute float detailSampleDist;
	attribute float detailSampleMaxError;
};

interface rcSpan {
	attribute long smin;
	attribute long smax;
	attribute long area; 
	//[Value] attribute rcSpan next;
};

// interface rcSpanPool {
// 	[Value] attribute rcSpanPool next;					
// 	[Value] attribute rcSpan items;	
// };


/// A dynamic heightfield representing obstructed space.
/// @ingroup recast
interface rcHeightfield
{
	void rcHeightfield();

	attribute int width;			///< The width of the heightfield. (Along the x-axis in cell units.)
	attribute int height;			///< The height of the heightfield. (Along the z-axis in cell units.)
	//attribute float bmin[3];  	///< The minimum bounds in world space. [(x, y, z)]
	//attribute float bmax[3];		///< The maximum bounds in world space. [(x, y, z)]
	attribute float cs;			///< The size of each cell. (On the xz-plane.)
	attribute float ch;			///< The height of each cell. (The minimum increment along the y-axis.)
	// rcSpan** spans;		///< Heightfield of spans (width*height).
	// rcSpanPool* pools;	///< Linked list of span pools.
	// rcSpan* freelist;	///< The next free span.
};

/// Provides information on the content of a cell column in a compact heightfield. 
interface rcCompactCell
{
	attribute int index;	///< Index to the first span in the column.
	attribute int count;		///< Number of spans in the column.
};

/// Represents a span of unobstructed space within a compact heightfield.
interface rcCompactSpan
{
	attribute short y;			///< The lower extent of the span. (Measured from the heightfield's base.)
	attribute short reg;			///< The id of the region the span belongs to. (Or zero if not in a region.)
	attribute int con;		///< Packed neighbor connection data.
	attribute int h;			///< The height of the span.  (Measured from #y.)
};

/// A compact, static heightfield representing unobstructed space.
/// @ingroup recast
interface rcCompactHeightfield
{
	void rcCompactHeightfield();
	attribute int width;					///< The width of the heightfield. (Along the x-axis in cell units.)
	attribute int height;					///< The height of the heightfield. (Along the z-axis in cell units.)
	attribute int spanCount;				///< The number of spans in the heightfield.
	attribute int walkableHeight;			///< The walkable height used during the build of the field.  (See: rcConfig::walkableHeight)
	attribute int walkableClimb;			///< The walkable climb used during the build of the field. (See: rcConfig::walkableClimb)
	attribute int borderSize;				///< The AABB border size used during the build of the field. (See: rcConfig::borderSize)
	attribute int maxDistance;	///< The maximum distance value of any span within the field. 
	attribute int maxRegions;	///< The maximum region id of any span within the field. 
	//attribute float bmin[3];				///< The minimum bounds in world space. [(x, y, z)]
	//attribute float bmax[3];				///< The maximum bounds in world space. [(x, y, z)]
	attribute float cs;					///< The size of each cell. (On the xz-plane.)
	attribute float ch;					///< The height of each cell. (The minimum increment along the y-axis.)
	//[Value] attribute rcCompactCell cells;		///< Array of cells. [Size: #width*#height]
	//[Value] attribute rcCompactSpan spans;		///< Array of spans. [Size: #spanCount]
	// attribute unsigned short* dist;		///< Array containing border distance data. [Size: #spanCount]
	// attribute unsigned char* areas;		///< Array containing area id data. [Size: #spanCount]
};

/// Represents a heightfield layer within a layer set.
/// @see rcHeightfieldLayerSet
interface rcHeightfieldLayer
{
	//attribute float bmin[3];				///< The minimum bounds in world space. [(x, y, z)]
	//attribute float bmax[3];				///< The maximum bounds in world space. [(x, y, z)]
	attribute float cs;					///< The size of each cell. (On the xz-plane.)
	attribute float ch;					///< The height of each cell. (The minimum increment along the y-axis.)
	attribute int width;					///< The width of the heightfield. (Along the x-axis in cell units.)
	attribute int height;					///< The height of the heightfield. (Along the z-axis in cell units.)
	attribute int minx;					///< The minimum x-bounds of usable data.
	attribute int maxx;					///< The maximum x-bounds of usable data.
	attribute int miny;					///< The minimum y-bounds of usable data. (Along the z-axis.)
	attribute int maxy;					///< The maximum y-bounds of usable data. (Along the z-axis.)
	attribute int hmin;					///< The minimum height bounds of usable data. (Along the y-axis.)
	attribute int hmax;					///< The maximum height bounds of usable data. (Along the y-axis.)
	// attribute unsigned char* heights;		///< The heightfield. [Size: width * height]
	// attribute unsigned char* areas;		///< Area ids. [Size: Same as #heights]
	// attribute unsigned char* cons;		///< Packed neighbor connection information. [Size: Same as #heights]
};

/// Represents a set of heightfield layers.
/// @ingroup recast
/// @see rcAllocHeightfieldLayerSet, rcFreeHeightfieldLayerSet 
interface rcHeightfieldLayerSet
{
	void rcHeightfieldLayerSet();
	//[Value] attribute rcHeightfieldLayer layers;			///< The layers in the set. [Size: #nlayers]
	attribute int nlayers;						///< The number of layers in the set.
};

/// Represents a simple, non-overlapping contour in field space.
interface rcContour
{
	//attribute int* verts;			///< Simplified contour vertex and connection data. [Size: 4 * #nverts]
	attribute int nverts;			///< The number of vertices in the simplified contour. 
	//attribute int* rverts;		///< Raw contour vertex and connection data. [Size: 4 * #nrverts]
	attribute int nrverts;		///< The number of vertices in the raw contour. 
	attribute int reg;	///< The region id of the contour.
	//attribute unsigned char area;	///< The area id of the contour.
};

/// Represents a group of related contours.
/// @ingroup recast
interface rcContourSet
{
	void rcContourSet();
	//[Value] attribute rcContour[] conts;	///< An array of the contours in the set. [Size: #nconts]
	attribute int nconts;			///< The number of contours in the set.
	//attribute float bmin[3];  	///< The minimum bounds in world space. [(x, y, z)]
	//attribute float bmax[3];		///< The maximum bounds in world space. [(x, y, z)]
	attribute float cs;			///< The size of each cell. (On the xz-plane.)
	attribute float ch;			///< The height of each cell. (The minimum increment along the y-axis.)
	attribute int width;			///< The width of the set. (Along the x-axis in cell units.) 
	attribute int height;			///< The height of the set. (Along the z-axis in cell units.) 
	attribute int borderSize;		///< The AABB border size used to generate the source data from which the contours were derived.
	attribute float maxError;		///< The max edge error that this contour set was simplified with.
};

/// Represents a polygon mesh suitable for use in building a navigation mesh. 
/// @ingroup recast
interface rcPolyMesh
{
	void rcPolyMesh();

	// unsigned short* verts;	///< The mesh vertices. [Form: (x, y, z) * #nverts]
	// unsigned short* polys;	///< Polygon and neighbor data. [Length: #maxpolys * 2 * #nvp]
	// unsigned short* regs;	///< The region id assigned to each polygon. [Length: #maxpolys]
	// unsigned short* flags;	///< The user defined flags for each polygon. [Length: #maxpolys]
	// unsigned char* areas;	///< The area id assigned to each polygon. [Length: #maxpolys]
	attribute int nverts;				///< The number of vertices.
	attribute int npolys;				///< The number of polygons.
	attribute int maxpolys;			///< The number of allocated polygons.
	attribute int nvp;				///< The maximum number of vertices per polygon.
	//attribute float bmin[3];			///< The minimum bounds in world space. [(x, y, z)]
	//attribute float bmax[3];			///< The maximum bounds in world space. [(x, y, z)]
	attribute float cs;				///< The size of each cell. (On the xz-plane.)
	attribute float ch;				///< The height of each cell. (The minimum increment along the y-axis.)
	attribute int borderSize;			///< The AABB border size used to generate the source data from which the mesh was derived.
	attribute float maxEdgeError;		///< The max error of the polygon edges in the mesh.
};

/// Contains triangle meshes that represent detailed height data associated 
/// with the polygons in its associated polygon mesh object.
/// @ingroup recast
interface rcPolyMeshDetail
{
	//attribute unsigned int* meshes;	///< The sub-mesh data. [Size: 4*#nmeshes] 
	//float* verts;			///< The mesh vertices. [Size: 3*#nverts] 
	//unsigned char* tris;	///< The mesh triangles. [Size: 4*#ntris] 
	attribute long nmeshes;			///< The number of sub-meshes defined by #meshes.
	attribute long nverts;				///< The number of vertices in #verts.
	attribute long ntris;				///< The number of triangles in #tris.
};

interface FloatArray {
	void FloatArray(int size);
	float Get(int index);
	void Set(int index, float value);
};

interface IntArray {
	void IntArray(int size);
	int Get(int index);
	void Set(int index, int value);
};

interface CharArray {
	void CharArray(int size);
	char Get(int index);
	void Set(int index, char value);
};

interface Recast{
	[Static] void rcFreeHeightField(rcHeightfield hf);
	[Static] rcHeightfield rcAllocHeightfield();
	[Static] rcCompactHeightfield rcAllocCompactHeightfield();
	[Static] void rcFreeCompactHeightfield(rcCompactHeightfield chf);
	[Static] rcHeightfieldLayerSet rcAllocHeightfieldLayerSet();
	[Static] void rcFreeHeightfieldLayerSet(rcHeightfieldLayerSet lset);
	[Static] rcContourSet rcAllocContourSet();
	[Static] void rcFreeContourSet(rcContourSet cset);
	[Static] rcPolyMesh rcAllocPolyMesh();
	[Static] void rcFreePolyMesh(rcPolyMesh pmesh);
	[Static] rcPolyMeshDetail rcAllocPolyMeshDetail();
	[Static] void rcFreePolyMeshDetail(rcPolyMeshDetail dmesh);

	[Static] void rcCalcBounds([Const] FloatArray verts, int nv, FloatArray bmin, FloatArray bmax);

	[Static] void rcCalcGridSize([Const] FloatArray bmin, [Const] FloatArray bmax, float cs,
							IntArray w, IntArray h);

	[Static] bool rcCreateHeightfield(rcContext ctx, [Ref] rcHeightfield hf, int width, int height, 
							[Const] FloatArray bmin, [Const] FloatArray bmax, float cs, float ch);

	[Static] void rcMarkWalkableTriangles(rcContext ctx, [Const] float walkableSlopeAngle, 
							[Const] FloatArray verts, int nv,[Const] IntArray tris, int nt, CharArray areas); 

	[Static] void rcClearUnwalkableTriangles(rcContext ctx, [Const] float walkableSlopeAngle, 
							[Const] FloatArray verts, int nv,[Const] IntArray tris, int nt, CharArray areas); 

	[Static] bool rcAddSpan(rcContext ctx, [Ref] rcHeightfield hf, [Const] int x, [Const] int y, 
							[Const] int smin, [Const] int smax, [Const] int area, [Const] int flagMergeThr);

	[Static] bool rcRasterizeTriangle(rcContext ctx, [Const] FloatArray v0, [Const] FloatArray v1, 
							[Const] FloatArray v2, [Const] int area, [Ref] rcHeightfield solid, [Const] int flagMergeThr);

	[Static] bool rcRasterizeTriangles(rcContext ctx, [Const]  FloatArray verts, [Const]  int nv,
							[Const]  IntArray tris, [Const]  CharArray areas, [Const]  int nt,
							[Ref] rcHeightfield solid, [Const]  int flagMergeThr);

	[Static] bool rcRasterizeTriangles(rcContext ctx, [Const]  FloatArray verts, [Const]  CharArray areas, [Const]  int nt,
							[Ref] rcHeightfield solid, [Const]  int flagMergeThr);

	[Static] void rcFilterLowHangingWalkableObstacles(rcContext ctx, [Const]  int walkableClimb, [Ref] rcHeightfield solid);

	[Static] void rcFilterLedgeSpans(rcContext ctx, [Const]  int walkableHeight,
							[Const]  int walkableClimb, [Ref] rcHeightfield solid);

	[Static] void rcFilterWalkableLowHeightSpans(rcContext ctx, int walkableHeight, [Ref] rcHeightfield solid);

	[Static] int rcGetHeightFieldSpanCount(rcContext ctx, [Ref] rcHeightfield hf);

	[Static] bool rcBuildCompactHeightfield(rcContext ctx, [Const]  int walkableHeight, [Const]  int walkableClimb,
							[Ref] rcHeightfield hf, [Ref] rcCompactHeightfield chf);

	[Static] bool rcErodeWalkableArea(rcContext ctx, int radius, [Ref] rcCompactHeightfield chf);

	[Static] bool rcMedianFilterWalkableArea(rcContext ctx, [Ref] rcCompactHeightfield chf);

	[Static] void rcMarkBoxArea(rcContext ctx, [Const]  FloatArray bmin, [Const]  FloatArray bmax, char areaId,
							[Ref] rcCompactHeightfield chf);

	[Static] void rcMarkConvexPolyArea(rcContext ctx, [Const]  FloatArray verts, [Const]  int nverts,
							[Const]  float hmin, [Const]  float hmax, char areaId,
							[Ref] rcCompactHeightfield chf);

	[Static] int rcOffsetPoly([Const]  FloatArray verts, [Const]  int nverts, [Const]  float offset,
							FloatArray outVerts, [Const]  int maxOutVerts);

	[Static] void rcMarkCylinderArea(rcContext ctx, [Const]  FloatArray pos,
							[Const]  float r, [Const]  float h, char areaId,
							[Ref] rcCompactHeightfield chf);

	[Static] bool rcBuildDistanceField(rcContext ctx, [Ref] rcCompactHeightfield chf);

	[Static] bool rcBuildRegions(rcContext ctx, [Ref] rcCompactHeightfield chf,
							[Const]  int borderSize, [Const]  int minRegionArea, [Const]  int mergeRegionArea);

	[Static] bool rcBuildLayerRegions(rcContext ctx, [Ref] rcCompactHeightfield chf, 
							[Const]  int borderSize, [Const]  int minRegionArea);

	[Static] bool rcBuildRegionsMonotone(rcContext ctx, [Ref] rcCompactHeightfield chf, 
							[Const]  int borderSize, [Const]  int minRegionArea, [Const]  int mergeRegionArea);
};
